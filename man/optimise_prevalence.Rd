% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimise_prevalence.R
\name{optimise_s_prevalence}
\alias{optimise_s_prevalence}
\alias{optimise_sN_prevalence}
\alias{optimise_random_prevalence}
\title{Optimising the pool size and number for estimating prevalence.}
\usage{
optimise_s_prevalence(
  pool_number = 1,
  prevalence,
  cost_unit,
  cost_pool,
  cost_cluster = NA,
  correlation = NA,
  sensitivity = 1,
  specificity = 1,
  max_s = 50,
  form = "beta",
  interval = 0
)

optimise_sN_prevalence(
  prevalence,
  cost_unit,
  cost_pool,
  cost_cluster,
  correlation,
  sensitivity = 1,
  specificity = 1,
  max_s = 50,
  max_N = 20,
  form = "beta"
)

optimise_random_prevalence(
  catch_mean,
  catch_variance,
  pool_strat_family,
  prevalence,
  cost_unit,
  cost_pool,
  cost_period,
  cost_cluster = NA,
  correlation = NA,
  sensitivity = 1,
  specificity = 1,
  max_period = 10,
  form = "beta",
  verbose = FALSE
)
}
\arguments{
\item{pool_number}{numeric The number of pools per cluster. Must be a numeric
value greater than or equal to 0.}

\item{prevalence}{numeric The proportion of units that carry the marker of
interest (i.e. true positive). Must be be a numeric value between 0 and 1,
inclusive of both.}

\item{cost_unit}{numeric The cost to process a single unit. Must be a numeric
value greater than or equal to 0.}

\item{cost_pool}{numeric The cost to process a single pool. Must be a numeric
value greater than or equal to 0.}

\item{cost_cluster}{numeric/NA The cost to process a cluster. Must be a
numeric value greater than or equal to 0. For `optimise_s_prevalence()`,
this can be ignored if correlation is NA.}

\item{correlation}{numeric The correlation between test results within a
single cluster (units in different clusters are assumed to be
uncorrelated). Must be a numeric value between 0 and 1, inclusive of both.
A value of 1 indicates that units within clusters are perfectly correlated
(there are no differences units within a single cluster). A value of 0
indicates that units within clusters are no more correlated than units in
different clusters.}

\item{sensitivity}{numeric The probability that the test correctly identifies
a true positive. Must be a numeric value between 0 and 1, inclusive of
both. A value of 1 indicates that the test can perfectly identify all true
positives.}

\item{specificity}{numeric The probability that the test correctly identifies
a true negative. Must be a numeric value between 0 and 1, inclusive of
both. A value of 1 indicates that the test can perfectly identify all true
negatives.}

\item{max_s}{numeric The maximum number of units per pool (pool size).}

\item{form}{string The distribution used to model the cluster-level
prevalence and correlation of units within cluster. Select one of "beta",
"logitnorm" or "cloglognorm". See details.}

\item{interval}{Range of near-optimal designs to consider. If interval == 0
(the default) only returns optimal design. If interval > 0, function
identifies range of designs with cost less than the optimal cost * (1 +
interval).}

\item{max_N}{numeric The maximum number of pools per cluster (pool number).}

\item{catch_mean, catch_variance}{numeric The mean and variance of the number
of units collected per collection period. Both must be greater than 0 and
`catch_variance` must be greater than or equal to `catch_mean`. Number of
units caught per period is assumed to follow a negative binomial
distribution (or Poisson distribution if `catch_mean = catch_variance`)}

\item{pool_strat_family}{function A function that defines a family of rules
for how a number of units will be divided into pools, e.g.
`pool_max_size()` and `pool_target_number()`. The function must take
positive integer valued parameters, and return a function that defines a
pooling strategy}

\item{cost_period}{numeric The cost per collection period (per collection per
cluster if `correlation` is not `NA`). Most be a numeric value greater than
or equal to 0.}

\item{max_period}{numeric The maximum number of collection periods (per
cluster if `correlation` is not `NA`)}

\item{verbose}{logical Should function indicate progress by printing each
parameter set calculated to screen? If FALSE (default) only prints optimal
parameters identified in each iteration}
}
\value{
`optimise_s_prevalence` returns a list with the optimal pool size
  `s`, the unit cost of Fisher information, and range of near-optimal designs
  `catch`. `optimise_sN_prevalence()` returns the same list as
  `optimise_s_prevalence` with an additional optimal pool number `N`.
  `optimise_random_prevlance` returns a list including the optimal number of
  sampling periods; the unit cost of Fisher information; the mean, variance,
  and distribution of the number of units caught across all sampling
  periods(per cluster where applicable); and the optimal pooling strategy.
}
\description{
These functions determine cost-effective pooling strategies for estimating
the prevalence of a marker in a population. Both functions attempt to choose
survey designs that maximise the Fisher Information for given cost or effort.
`optimise_s_prevalence()` calculates the optimal single pool size that
balances the cost and accuracy given the marker prevalence, test sensitivity,
and specificity, and works for simple random surveys or cluster surveys.
`optimise_sN_prevalence()` also attempts to identify the optimal number of
pools per cluster (cluster-surveys only). `optimise_random_prevalence()`
works for designs where collection proceeds for a number of collection
periods, but the number of units collected (and therefore the pool sizes,
pool numbers, and total cost) is random. Given the mean and variance of the
catch sizes per collection period and a family of pooling strategies, it
calculates the optimal combination of number of sampling periods and pooling
strategy.
}
\examples{
optimise_s_prevalence(prevalence = 0.01, cost_unit = 5, cost_pool = 10)

optimise_sN_prevalence(
  prevalence = 0.01, cost_unit = 5, cost_pool = 10,
  cost_cluster = 100, correlation = 0.05
  )
}
